export type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>> | T;
export type Enumerate<N extends number, Acc extends number[] = []> = Acc["length"] extends N ? Acc[number] : Enumerate<N, [...Acc, Acc["length"]]>;
export type ExcludeArray<T> = T extends unknown[] ? never : T;
export type Arr<T, N extends number, Acc extends T[] = []> = Acc["length"] extends N ? Acc : Arr<T, N, [...Acc, T]>;
export type PartialDeepMerge<T, U> = {
    [P in keyof T | keyof U]?: P extends keyof T & keyof U ? T[P] extends object ? U[P] extends object ? PartialDeepMerge<T[P], U[P]> : T[P] | U[P] : T[P] | U[P] : P extends keyof T ? T[P] : P extends keyof U ? U[P] : never;
};
export type Spread<A extends readonly [...unknown[]]> = A extends [
    infer L,
    ...infer R
] ? SpreadTwo<L, Spread<R>> : unknown;
type SpreadTwo<L, R> = Id<Pick<L, Exclude<keyof L, keyof R>> & Pick<R, Exclude<keyof R, OptionalPropertyNames<R>>> & Pick<R, Exclude<OptionalPropertyNames<R>, keyof L>> & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>>;
type Id<T> = T extends infer U ? {
    [K in keyof U]: U[K];
} : never;
type SpreadProperties<L, R, K extends keyof L & keyof R> = {
    [P in K]: L[P] | Exclude<R[P], undefined>;
};
type OptionalPropertyNames<T> = {
    [K in keyof T]-?: object extends {
        [P in K]: T[K];
    } ? K : never;
}[keyof T];
export {};
